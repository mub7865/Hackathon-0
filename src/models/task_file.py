"""
TaskFile Model

Represents a task file with YAML frontmatter and markdown content.
"""

import os
import hashlib
from datetime import datetime, timezone
from typing import Dict, Any, Optional
from ..utils.yaml_handler import parse_frontmatter, write_frontmatter


class TaskFile:
    """Model for task files in the vault."""

    def __init__(self, file_path: str):
        """
        Initialize TaskFile from file path.

        Args:
            file_path: Path to task file
        """
        self.file_path = file_path
        self.metadata: Dict[str, Any] = {}
        self.content: str = ""

        if os.path.exists(file_path):
            self.read()

    @staticmethod
    def generate_task_id(filename: str) -> str:
        """
        Generate unique task ID from filename and timestamp.

        Args:
            filename: Original filename

        Returns:
            Task ID in format: task-YYYYMMDD-HHMMSS-hash
        """
        now = datetime.now(timezone.utc)
        timestamp = now.strftime('%Y%m%d-%H%M%S')

        # Generate hash from filename + timestamp
        hash_input = f"{filename}{now.isoformat()}".encode('utf-8')
        hash_value = hashlib.sha256(hash_input).hexdigest()[:6]

        return f"task-{timestamp}-{hash_value}"

    @staticmethod
    def create_from_file(original_file_path: str, vault_path: str) -> 'TaskFile':
        """
        Create a new task file from an original file.

        Args:
            original_file_path: Path to original file in Inbox
            vault_path: Path to vault root

        Returns:
            New TaskFile instance
        """
        filename = os.path.basename(original_file_path)
        task_id = TaskFile.generate_task_id(filename)

        # Create task file path
        task_filename = f"{task_id}.md"
        task_path = os.path.join(vault_path, "Needs_Action", task_filename)

        # Read original file content
        from ..utils.file_parser import get_file_content, get_file_mime_type
        original_content = get_file_content(original_file_path)

        # Create metadata
        metadata = {
            'id': task_id,
            'type': 'document_analysis',
            'status': 'pending',
            'created_at': datetime.now(timezone.utc).isoformat(),
            'processed_at': None,
            'original_file': {
                'name': filename,
                'path': f"Inbox/{filename}",
                'size_bytes': os.path.getsize(original_file_path),
                'mime_type': get_file_mime_type(original_file_path)
            },
            'processing': None,
            'tags': []
        }

        # Create markdown content
        content = f"""# Task: Analyze {filename}

## Original Content

{original_content}

## AI Analysis

[To be generated by AI processing]

## Action Items

[To be extracted by AI]

## Metadata

**Created**: {metadata['created_at']}
**Status**: {metadata['status']}
"""

        # Create task file
        task = TaskFile(task_path)
        task.metadata = metadata
        task.content = content
        task.write()

        return task

    def read(self):
        """Read task file from disk."""
        if not os.path.exists(self.file_path):
            raise FileNotFoundError(f"Task file not found: {self.file_path}")

        with open(self.file_path, 'r', encoding='utf-8') as f:
            file_content = f.read()

        self.metadata, self.content = parse_frontmatter(file_content)

    def write(self):
        """Write task file to disk."""
        full_content = write_frontmatter(self.metadata, self.content)

        # Ensure directory exists
        os.makedirs(os.path.dirname(self.file_path), exist_ok=True)

        with open(self.file_path, 'w', encoding='utf-8') as f:
            f.write(full_content)

    def update_status(self, status: str):
        """
        Update task status.

        Args:
            status: New status (pending, processing, completed, failed)
        """
        self.metadata['status'] = status
        if status == 'completed':
            self.metadata['processed_at'] = datetime.now(timezone.utc).isoformat()
        self.write()

    def add_processing_metadata(self, model: str, duration: int, tokens: int):
        """
        Add processing metadata after AI completion.

        Args:
            model: AI model used
            duration: Processing duration in seconds
            tokens: Token count used
        """
        self.metadata['processing'] = {
            'model': model,
            'duration_seconds': duration,
            'token_count': tokens
        }
        self.write()

    def move_to_done(self, vault_path: str):
        """
        Move task file to Done folder.

        Args:
            vault_path: Path to vault root
        """
        filename = os.path.basename(self.file_path)
        new_path = os.path.join(vault_path, "Done", filename)

        # Update file path
        os.rename(self.file_path, new_path)
        self.file_path = new_path

    def validate(self) -> bool:
        """
        Validate task file structure.

        Returns:
            True if valid, False otherwise
        """
        required_fields = ['id', 'type', 'status', 'created_at', 'original_file']
        return all(field in self.metadata for field in required_fields)
